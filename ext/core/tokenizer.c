/* Generated by re2c 2.0.3 on Mon Dec 20 17:29:25 2021 */
#line 1 "ext/core/tokenizer.re"
#include "tokenizer.h"
#include "ruby.h"

typedef enum {
  STACK_TOKEN_DBL_QUOTE,
  STACK_TOKEN_SNGL_QUOTE,
} StackToken;


#define TOKEN_STACK_CAPA 1024

typedef struct {
  uint8_t stack_data[TOKEN_STACK_CAPA];
  uint8_t *data;
  uint16_t index;
  uint16_t capa;
} TokenStack;

typedef struct {
  bool data[QUOTE_TYPE_MAX];
} InsideStringAry;

typedef struct {
  uint16_t bracket_type;
  uint16_t prev_bracket_type;
  InsideStringAry inside_string;
  TokenStack stack;

  // re2c stuff
  char *padded_input;
  char *yymarker;
  char *yyctxmarker;
  char *yycursor;
  char *yylimit;

} TokenizerState;


static void
tokenizer_state_push(TokenizerState *s, StackToken t) {
  TokenStack *st = &s->stack;
  if(st->index >= st->capa) {
    size_t old_capa = st->capa;
    st->capa = st->capa + st->capa;
    if(st->data == st->stack_data) {
      uint8_t *heap_data = ALLOC_N(uint8_t, st->capa);
      MEMCPY(heap_data, st->stack_data, uint8_t, old_capa);
      st->data = heap_data;
    } else {
      REALLOC_N(st->data, uint8_t, st->capa);
    }
  }
  st->data[st->index++] = t;
}

static void
tokenizer_add_token(Tokenizer *tokenizer, Token token) {
    if (tokenizer->tokens_len >= tokenizer->tokens_capa) {
      size_t new_tokens_capa = (tokenizer->tokens_capa) * 2;
      RB_REALLOC_N(tokenizer->tokens, Token, new_tokens_capa);
      tokenizer->tokens_capa = new_tokens_capa;
    }

    tokenizer->tokens[tokenizer->tokens_len] = token;
    tokenizer->tokens_len++;
}

#define YYMAXFILL 2


static void
tokenizer_state_init(TokenizerState *s, Tokenizer *tokenizer) {
  TokenizerState empty_s = {0,};
  *s = empty_s;
  s->stack.capa = TOKEN_STACK_CAPA;
  s->stack.data = s->stack.stack_data;

  s->padded_input = (char *) xmalloc(tokenizer->input_len + YYMAXFILL);
  memcpy(s->padded_input, tokenizer->input, tokenizer->input_len);
  memset(s->padded_input + tokenizer->input_len, 0, YYMAXFILL);
  s->yycursor = s->padded_input;
  s->yylimit = s->yycursor + tokenizer->input_len + YYMAXFILL;
}

static void
tokenizer_state_destroy(TokenizerState *s) {
  xfree(s->padded_input);
}

static void
tokenizer_state_save(TokenizerState *s) {
}

#line 107 "ext/core/tokenizer.re"


#line 40 "/usr/share/re2c/stdlib/unicode_categories.re"



static bool
tokenizer_state_inside_string(TokenizerState *s) {
  return s->inside_string.data[QUOTE_TYPE_SNGL] || s->inside_string.data[QUOTE_TYPE_DBL];
}

static bool
tokenizer_next(Tokenizer *tokenizer, TokenizerState *s) {
  Token t = {0, };

redo:
  t.start_byte = s->yycursor - s->padded_input;

  
#line 117 "ext/core/tokenizer.c"
{
	unsigned char yych;
	unsigned int yyaccept = 0;
	if ((s->yylimit - s->yycursor) < 2) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case 0x00:
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
	case '\v':
	case '\f':
	case 0x0E:
	case 0x0F:
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1A:
	case 0x1B:
	case 0x1C:
	case 0x1D:
	case 0x1E:
	case 0x1F:
	case 0x7F:	goto yy2;
	case '\t':
	case ' ':	goto yy5;
	case '\n':
	case '\r':	goto yy8;
	case '!':
	case '#':
	case '$':
	case '%':
	case '&':
	case ',':
	case '.':
	case ':':
	case '?':
	case '@':
	case '\\':
	case '^':
	case '_':
	case '`':
	case '|':
	case '~':	goto yy11;
	case '"':	goto yy14;
	case '\'':	goto yy16;
	case '(':
	case '<':
	case '[':
	case '{':	goto yy18;
	case ')':
	case '>':
	case ']':
	case '}':	goto yy20;
	case '*':
	case '+':
	case '-':
	case '/':
	case '=':	goto yy22;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy24;
	case ';':	goto yy27;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy28;
	default:	goto yy31;
	}
yy2:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case 0x00:
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
	case '\v':
	case '\f':
	case 0x0E:
	case 0x0F:
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1A:
	case 0x1B:
	case 0x1C:
	case 0x1D:
	case 0x1E:
	case 0x1F:
	case 0x7F:	goto yy2;
	default:	goto yy4;
	}
yy4:
#line 201 "ext/core/tokenizer.re"
	{ 
    t.type = CHAR_TYPE_OTHER;
    goto end;
  }
#line 297 "ext/core/tokenizer.c"
yy5:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case '\t':
	case ' ':	goto yy5;
	default:	goto yy7;
	}
yy7:
#line 134 "ext/core/tokenizer.re"
	{
    bool inside_string = tokenizer_state_inside_string(s);
    if(!inside_string) {
       goto redo;
    } else {
      t.type = CHAR_TYPE_SPACE;
      goto end;
    }
  }
#line 318 "ext/core/tokenizer.c"
yy8:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case '\n':
	case '\r':	goto yy8;
	default:	goto yy10;
	}
yy10:
#line 124 "ext/core/tokenizer.re"
	{ 
    bool inside_string = tokenizer_state_inside_string(s);
    if(!inside_string) {
       goto redo;
    } else {
      t.type = CHAR_TYPE_LINE;
      goto end;
    }
  }
#line 339 "ext/core/tokenizer.c"
yy11:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
yy12:
	switch (yych) {
	case '!':
	case '#':
	case '$':
	case '%':
	case '&':
	case ',':
	case '.':
	case ':':
	case ';':
	case '?':
	case '@':
	case '\\':
	case '^':
	case '_':
	case '`':
	case '|':
	case '~':	goto yy11;
	default:	goto yy13;
	}
yy13:
#line 150 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_PUNCT;
    goto end;
  }
#line 371 "ext/core/tokenizer.c"
yy14:
	++s->yycursor;
#line 185 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_QUOTE;
    if(!s->inside_string.data[QUOTE_TYPE_SNGL]) {
      s->inside_string.data[QUOTE_TYPE_DBL] = !s->inside_string.data[QUOTE_TYPE_DBL];
    }
    goto end;
  }
#line 382 "ext/core/tokenizer.c"
yy16:
	++s->yycursor;
#line 193 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_QUOTE;
    if(!s->inside_string.data[QUOTE_TYPE_DBL]) {
      s->inside_string.data[QUOTE_TYPE_SNGL] = !s->inside_string.data[QUOTE_TYPE_SNGL];
    }
    goto end;
  }
#line 393 "ext/core/tokenizer.c"
yy18:
	++s->yycursor;
#line 155 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_BRACKET;
    goto end;
  }
#line 401 "ext/core/tokenizer.c"
yy20:
	yyaccept = 0;
	yych = *(s->yymarker = ++s->yycursor);
	switch (yych) {
	case '\t':
	case ' ':
		s->yyctxmarker = s->yycursor;
		goto yy33;
	case '\n':
	case '\r':
		s->yyctxmarker = s->yycursor;
		goto yy36;
	default:	goto yy21;
	}
yy21:
#line 165 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_BRACKET;
    goto end;
  }
#line 422 "ext/core/tokenizer.c"
yy22:
	++s->yycursor;
#line 170 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_ARITH;
    goto end;
  }
#line 430 "ext/core/tokenizer.c"
yy24:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy24;
	default:	goto yy26;
	}
yy26:
#line 175 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_DIGIT;
    goto end;
  }
#line 454 "ext/core/tokenizer.c"
yy27:
	yyaccept = 1;
	yych = *(s->yymarker = ++s->yycursor);
	switch (yych) {
	case '\t':
	case ' ':
		s->yyctxmarker = s->yycursor;
		goto yy39;
	case '\n':
	case '\r':
		s->yyctxmarker = s->yycursor;
		goto yy41;
	default:	goto yy12;
	}
yy28:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy28;
	default:	goto yy30;
	}
yy30:
#line 180 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_ALPHA;
    goto end;
  }
#line 534 "ext/core/tokenizer.c"
yy31:
	++s->yycursor;
#line 206 "ext/core/tokenizer.re"
	{ 
    t.type = CHAR_TYPE_OTHER;
    goto redo;
  }
#line 542 "ext/core/tokenizer.c"
yy33:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case '\t':
	case ' ':	goto yy33;
	case '\n':
	case '\r':	goto yy36;
	default:	goto yy35;
	}
yy35:
	s->yycursor = s->yymarker;
	switch (yyaccept) {
	case 0:
		goto yy21;
	case 1:
		goto yy13;
	default:
		goto yy43;
	}
yy36:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case '\n':
	case '\r':	goto yy36;
	default:	goto yy38;
	}
yy38:
	s->yycursor = s->yyctxmarker;
#line 160 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_BRACKET;
    t.dont_start = true;
    goto end;
  }
#line 581 "ext/core/tokenizer.c"
yy39:
	++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case '\t':
	case ' ':	goto yy39;
	case '\n':
	case '\r':	goto yy41;
	default:	goto yy35;
	}
yy41:
	yyaccept = 2;
	s->yymarker = ++s->yycursor;
	if (s->yylimit <= s->yycursor) return false;;
	yych = *s->yycursor;
	switch (yych) {
	case '\t':
	case ' ':	goto yy39;
	case '\n':
	case '\r':	goto yy41;
	default:	goto yy43;
	}
yy43:
	s->yycursor = s->yyctxmarker;
#line 144 "ext/core/tokenizer.re"
	{
    t.type = CHAR_TYPE_PUNCT;
    t.dont_start = true;
    goto end;
  }
#line 613 "ext/core/tokenizer.c"
}
#line 211 "ext/core/tokenizer.re"


end:

  t.end_byte = s->yycursor - s->padded_input;
  if(t.end_byte <= tokenizer->input_len) {
    tokenizer_add_token(tokenizer, t);
  }
  return true;
}

void
tokenizer_run(Tokenizer *tokenizer) {
  TokenizerState s;
  tokenizer_state_init(&s, tokenizer);

  while(tokenizer_next(tokenizer, &s)) {}

  // size_t i;
  // for(i = 0; i < tokenizer->input_len; i++) {
  //   char c = tokenizer->input[i];
  //   tokenizer_feed(tokenizer, &s, c, i);
  // }

  // {
  //   tokenizer_feed(tokenizer, &s, '\0', i + 1);
  // }

  tokenizer_state_destroy(&s);
}